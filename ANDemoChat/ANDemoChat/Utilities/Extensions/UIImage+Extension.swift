//
//  UIImage+Extension.swift
//  ANDemoChat
//
//  Created by Au Nguyen on 5/17/19.
//  Copyright Â© 2019 AuNguyen. All rights reserved.
//

import ImageIO
import UIKit

public enum ImageFormat {
	case png
	case jpeg(CGFloat)
}

extension UIImage {
	func resizeImage(withWidth scaledToWidth: CGFloat) -> UIImage {
		let oldWidth = self.size.width
		let scaleFactor = scaledToWidth / oldWidth
		
		let newHeight = self.size.height * scaleFactor
		let newWidth = oldWidth * scaleFactor
		
		UIGraphicsBeginImageContext(CGSize(width: newWidth, height: newHeight))
		self.draw(in: CGRect(x: 0, y: 0, width: newWidth, height: newHeight))
		let newImage = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		return newImage!
	}
	
	public func base64(format: ImageFormat) -> String? {
		var imageData: Data?
		switch format {
        case .png: imageData = self.pngData()
		case .jpeg(let compression): imageData = self.jpegData(compressionQuality: compression)
		}
		return imageData?.base64EncodedString()
	}
}

extension UIImageView {
	
	open func setImage(string: String?,
					   color: UIColor? = nil,
					   circular: Bool = false,
					   textAttributes: [NSAttributedString.Key: Any]? = nil) {
		
		let image = imageSnap(text: string != nil ? string?.initials : "",
							  color: color ?? .random,
							  circular: circular,
							  textAttributes:textAttributes)
		
		if let newImage = image {
			self.image = newImage
		}
	}
	
	private func imageSnap(text: String?,
						   color: UIColor,
						   circular: Bool,
						   textAttributes: [NSAttributedString.Key: Any]?) -> UIImage? {
		
		let scale = Float(UIScreen.main.scale)
		var size = bounds.size
		if contentMode == .scaleToFill || contentMode == .scaleAspectFill || contentMode == .scaleAspectFit || contentMode == .redraw {
			size.width = CGFloat(floorf((Float(size.width) * scale) / scale))
			size.height = CGFloat(floorf((Float(size.height) * scale) / scale))
		}
		
		UIGraphicsBeginImageContextWithOptions(size, false, CGFloat(scale))
		let context = UIGraphicsGetCurrentContext()
		if circular {
			let path = CGPath(ellipseIn: bounds, transform: nil)
			context?.addPath(path)
			context?.clip()
		}
		
		// Fill
		context?.setFillColor(color.cgColor)
		context?.fill(CGRect(x: 0, y: 0, width: size.width, height: size.height))
		
		// Text
		if let text = text {
			let attributes = textAttributes ?? [NSAttributedString.Key.foregroundColor: UIColor.white,
												NSAttributedString.Key.font: UIFont.systemFont(ofSize: 15.0)]
			
			let textSize = text.size(withAttributes: attributes)
			let bounds = self.bounds
			let rect = CGRect(x: bounds.size.width/2 - textSize.width/2, y: bounds.size.height/2 - textSize.height/2, width: textSize.width, height: textSize.height)
			
			text.draw(in: rect, withAttributes: attributes)
		}
		
		let image = UIGraphicsGetImageFromCurrentImageContext()
		UIGraphicsEndImageContext()
		
		return image
	}
}

// MARK: UIColor Helper

extension UIColor {
	
	/// Returns random generated color.
	public static var random: UIColor {
		srandom(arc4random())
		var red: Double = 0
		
		while (red < 0.1 || red > 0.84) {
			red = drand48()
		}
		
		var green: Double = 0
		while (green < 0.1 || green > 0.84) {
			green = drand48()
		}
		
		var blue: Double = 0
		while (blue < 0.1 || blue > 0.84) {
			blue = drand48()
		}
		
		return .init(red: CGFloat(red), green: CGFloat(green), blue: CGFloat(blue), alpha: 1.0)
	}
	
	public static func colorHash(name: String?) -> UIColor {
		guard let name = name else {
			return .red
		}
		
		var nameValue = 0
		for character in name {
			let characterString = String(character)
			let scalars = characterString.unicodeScalars
			nameValue += Int(scalars[scalars.startIndex].value)
		}
		
		var r = Float((nameValue * 123) % 51) / 51
		var g = Float((nameValue * 321) % 73) / 73
		var b = Float((nameValue * 213) % 91) / 91
		
		let defaultValue: Float = 0.84
		r = min(max(r, 0.1), defaultValue)
		g = min(max(g, 0.1), defaultValue)
		b = min(max(b, 0.1), defaultValue)
		
		return .init(red: CGFloat(r), green: CGFloat(g), blue: CGFloat(b), alpha: 1.0)
	}
}

// MARK: String Helper

extension String {
	
	public var initials: String {
		var finalString = String()
		var words = components(separatedBy: .whitespacesAndNewlines)
		
		if let firstCharacter = words.first?.first {
			finalString.append(String(firstCharacter))
			words.removeFirst()
		}
		
		if let lastCharacter = words.last?.first {
			finalString.append(String(lastCharacter))
		}
		
		return finalString.uppercased()
	}
}
